#!/usr/bin/env python

import debian.deb822
import subprocess
import argparse
import tempfile
import tarfile
import shutil
import sys
import os

# Python decorator voodoo to simplify argparse subparser setup.

def arg(*a, **k):
    return a, k

def cmd(*args):
    def wrapper(func):
        def setup(subp):
            for a, k in args:
                subp.add_argument(*a, **k)
            subp.set_defaults(func = func)
        func._setup_parser = setup
        return func
    return wrapper


# Context manager for temporary directories.

class tempdir(object):

    def __enter__(self):
        self.dn = tempfile.mkdtemp()
        return self.dn

    def __exit__(self, *oops):
        shutil.rmtree(self.dn)

# Docker process, mostly a context manager around subprocess.Popen.
# We could use the native Python Docker interface, but the packaged
# Debian version of that has a wildly different API than the version
# on GitHub.

class DockerError(Exception):
    "Docker returned failure."

class Docker(subprocess.Popen):

    def __init__(self, *args, **kwargs):
        super(Docker, self).__init__(("docker",) + args, **kwargs)

    def __enter__(self):
        return self

    def __exit__(self, *oops):
        status = self.wait()
        if status and all(o is None for o in oops):
            raise DockerError()

# Filter which acts like fakeroot for tarfile.TarFile.add() 

def fakeroot_filter(info):
    info.uname = info.gname = "root"
    info.uid   = info.gid   = 0
    return info


# Commands

@cmd(arg("--dist", default = "jessie",       help = "distribution for base docker image"),
     arg("--tag",  default = "baiji:jessie", help = "tag to use for constructed base docker image"),
)
def create_base(args):
    """
    Construct a base Docker image.

    This is mostly just the output of debootstrap, with a bit of extra
    setup to include git, build-essentials, and fakeroot.
    """

    with tempdir() as dn:
        subprocess.check_call(("fakeroot", "/usr/sbin/debootstrap", "--foreign", "--variant=buildd", args.dist, dn))
        with Docker("import", "-", args.tag, stdin = subprocess.PIPE) as docker:
            tar = tarfile.open(mode = "w|", fileobj = docker.stdin)
            tar.add(dn, ".", filter = fakeroot_filter)
            tar.close()
            docker.stdin.close()

    with Docker("build", "-t", args.tag, "-", stdin = subprocess.PIPE) as docker:
        docker.communicate('''\
            FROM {args.tag}
            RUN sed -i '/mount -t proc /d; /mount -t sysfs /d' /debootstrap/functions && /debootstrap/debootstrap --second-stage
            RUN apt-get update && apt-get install -y --no-install-recommends build-essential fakeroot git
        '''.format(args = args))


@cmd(arg("--tag",  default = "baiji:jessie", help = "tag of base docker image to update"),
)
def update_base(args):
    """
    Update a base Docker image.
    """

    with Docker("build", "-t", args.tag, "-", stdin = subprocess.PIPE) as docker:
       docker.communicate('''\
           FROM {args.tag}
           RUN apt-get update && apt-get upgrade -y --with-new-pkgs --no-install-recommends && apt-get autoremove && apt-get clean
       '''.format(args = args))


@cmd(arg("--tag",           default = "baiji:jessie",                           help = "tag of base docker image to use"),
     arg("--dsc",           required = True,  type = argparse.FileType("r"),    help = ".dsc file to build"),
     arg("--local-package", nargs = "+",                                        help = "local packages to make available to build"),
)
def build(args):
    """
    Build a binary package given a source package.

    In the long run we may want --dsc to be optional, with the implied
    action of building a source package from the current directory if
    --dsc isn't specified.  Later.
    """

    dsc = debian.deb822.Dsc(args.dsc)
    files = [os.path.join(os.path.dirname(args.dsc.name), f["name"]) for f in dsc["Files"]]
    dummy = debian.deb822.Deb822()
    dummy_name = dsc["Source"] + "-build-depends"
    dummy_fn = "{}_{}_all.deb".format(dummy_name, dsc["Version"])
    dummy["Depends"] = dsc["Build-Depends"]
    dummy["Package"] = dummy_name
    for tag in ("Version", "Maintainer", "Homepage"):
        dummy[tag] = dsc[tag]

    with tempdir() as dn:
        equivs = subprocess.Popen(("equivs-build", "/dev/stdin"), stdin = subprocess.PIPE, stdout = subprocess.PIPE, cwd = dn)
        equivs.communicate(str(dummy))
        if equivs.wait():
            sys.exit("Couldn't generate dummy dependency package")

        # Do something useful with generated file here
        subprocess.check_call(("dpkg", "-c", os.path.join(dn, dummy_fn)))


# Parse arguments and dispatch to one of the commands above.

def main():
    HF = type("HF", (argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter), {})
    parser = argparse.ArgumentParser(formatter_class = HF, description = __doc__)
    subparsers = parser.add_subparsers(title = "Commands", metavar = "")
    for name in sorted(globals()):
        func = globals()[name]
        try:
            setup_parser = func._setup_parser
        except:
            continue
        setup_parser(subparsers.add_parser(name.replace("_", "-"),
                                           formatter_class = HF,
                                           description = func.__doc__,
                                           help = (func.__doc__ or "").lstrip().partition("\n")[0]))
    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
